/**
 * Define Ruby with Auto Generated Blocks
 * @param {Blockly} Blockly The ScratchBlocks
 * @return {Blockly} Blockly defined Ruby generator.
 */
export default function (Blockly) {
    Blockly.Ruby.operator_add = function (block) {
        return ['"wip: operator_add"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.operator_subtract = function (block) {
        return ['"wip: operator_subtract"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.operator_multiply = function (block) {
        return ['"wip: operator_multiply"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.operator_divide = function (block) {
        return ['"wip: operator_divide"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.operator_random = function (block) {
        return ['"wip: operator_random"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.operator_lt = function (block) {
        return ['"wip: operator_lt"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.operator_equals = function (block) {
        return ['"wip: operator_equals"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.operator_gt = function (block) {
        return ['"wip: operator_gt"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.operator_and = function (block) {
        return ['"wip: operator_and"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.operator_or = function (block) {
        return ['"wip: operator_or"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.operator_not = function (block) {
        return ['"wip: operator_not"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.operator_join = function (block) {
        return ['"wip: operator_join"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.operator_letter_of = function (block) {
        return ['"wip: operator_letter_of"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.operator_length = function (block) {
        return ['"wip: operator_length"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.operator_contains = function (block) {
        return ['"wip: operator_contains"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.operator_mod = function (block) {
        return ['"wip: operator_mod"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.operator_round = function (block) {
        return ['"wip: operator_round"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.operator_mathop = function (block) {
        return ['"wip: operator_mathop"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.procedures_definition = function (block) {
        return '# wip: procedures_definition\n';
    };

    Blockly.Ruby.procedures_call = function (block) {
        return '# wip: procedures_call\n';
    };

    Blockly.Ruby.procedures_prototype = function (block) {
        return '# wip: procedures_prototype\n';
    };

    Blockly.Ruby.procedures_declaration = function (block) {
        return '# wip: procedures_declaration\n';
    };

    Blockly.Ruby.argument_reporter_boolean = function (block) {
        return ['"wip: argument_reporter_boolean"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.argument_reporter_string_number = function (block) {
        return ['"wip: argument_reporter_string_number"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.argument_editor_boolean = function (block) {
        return ['"wip: argument_editor_boolean"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.argument_editor_string_number = function (block) {
        return ['"wip: argument_editor_string_number"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.control_forever = function (block) {
        return '# wip: control_forever\n';
    };

    Blockly.Ruby.control_repeat = function (block) {
        return '# wip: control_repeat\n';
    };

    Blockly.Ruby.control_if = function (block) {
        return '# wip: control_if\n';
    };

    Blockly.Ruby.control_if_else = function (block) {
        return '# wip: control_if_else\n';
    };

    Blockly.Ruby.control_stop = function (block) {
        return '# wip: control_stop\n';
    };

    Blockly.Ruby.control_wait = function (block) {
        return '# wip: control_wait\n';
    };

    Blockly.Ruby.control_wait_until = function (block) {
        return '# wip: control_wait_until\n';
    };

    Blockly.Ruby.control_repeat_until = function (block) {
        return '# wip: control_repeat_until\n';
    };

    Blockly.Ruby.control_while = function (block) {
        return '# wip: control_while\n';
    };

    Blockly.Ruby.control_for_each = function (block) {
        return '# wip: control_for_each\n';
    };

    Blockly.Ruby.control_start_as_clone = function (block) {
        return '# wip: control_start_as_clone\n';
    };

    Blockly.Ruby.control_create_clone_of_menu = function (block) {
        return '# wip: control_create_clone_of_menu\n';
    };

    Blockly.Ruby.control_create_clone_of = function (block) {
        return '# wip: control_create_clone_of\n';
    };

    Blockly.Ruby.control_delete_this_clone = function (block) {
        return '# wip: control_delete_this_clone\n';
    };

    Blockly.Ruby.control_get_counter = function (block) {
        return ['"wip: control_get_counter"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.control_incr_counter = function (block) {
        return '# wip: control_incr_counter\n';
    };

    Blockly.Ruby.control_clear_counter = function (block) {
        return '# wip: control_clear_counter\n';
    };

    Blockly.Ruby.control_all_at_once = function (block) {
        return '# wip: control_all_at_once\n';
    };

    Blockly.Ruby.sensing_touchingobject = function (block) {
        return ['"wip: sensing_touchingobject"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.sensing_touchingobjectmenu = function (block) {
        return '# wip: sensing_touchingobjectmenu\n';
    };

    Blockly.Ruby.sensing_touchingcolor = function (block) {
        return ['"wip: sensing_touchingcolor"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.sensing_coloristouchingcolor = function (block) {
        return ['"wip: sensing_coloristouchingcolor"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.sensing_distanceto = function (block) {
        return ['"wip: sensing_distanceto"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.sensing_distancetomenu = function (block) {
        return '# wip: sensing_distancetomenu\n';
    };

    Blockly.Ruby.sensing_askandwait = function (block) {
        return '# wip: sensing_askandwait\n';
    };

    Blockly.Ruby.sensing_answer = function (block) {
        return ['"wip: sensing_answer"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.sensing_keypressed = function (block) {
        return ['"wip: sensing_keypressed"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.sensing_keyoptions = function (block) {
        return ['"wip: sensing_keyoptions"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.sensing_mousedown = function (block) {
        return ['"wip: sensing_mousedown"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.sensing_mousex = function (block) {
        return ['"wip: sensing_mousex"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.sensing_mousey = function (block) {
        return ['"wip: sensing_mousey"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.sensing_setdragmode = function (block) {
        return '# wip: sensing_setdragmode\n';
    };

    Blockly.Ruby.sensing_loudness = function (block) {
        return ['"wip: sensing_loudness"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.sensing_loud = function (block) {
        return ['"wip: sensing_loud"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.sensing_timer = function (block) {
        return ['"wip: sensing_timer"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.sensing_resettimer = function (block) {
        return '# wip: sensing_resettimer\n';
    };

    Blockly.Ruby.sensing_of_object_menu = function (block) {
        return '# wip: sensing_of_object_menu\n';
    };

    Blockly.Ruby.sensing_of = function (block) {
        return '# wip: sensing_of\n';
    };

    Blockly.Ruby.sensing_current = function (block) {
        return ['"wip: sensing_current"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.sensing_dayssince2000 = function (block) {
        return ['"wip: sensing_dayssince2000"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.sensing_username = function (block) {
        return ['"wip: sensing_username"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.sensing_userid = function (block) {
        return ['"wip: sensing_userid"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.data_variable = function (block) {
        return ['"wip: data_variable"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.data_setvariableto = function (block) {
        return '# wip: data_setvariableto\n';
    };

    Blockly.Ruby.data_changevariableby = function (block) {
        return '# wip: data_changevariableby\n';
    };

    Blockly.Ruby.data_showvariable = function (block) {
        return '# wip: data_showvariable\n';
    };

    Blockly.Ruby.data_hidevariable = function (block) {
        return '# wip: data_hidevariable\n';
    };

    Blockly.Ruby.data_listcontents = function (block) {
        return ['"wip: data_listcontents"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.data_listindexall = function (block) {
        return ['"wip: data_listindexall"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.data_listindexrandom = function (block) {
        return ['"wip: data_listindexrandom"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.data_addtolist = function (block) {
        return '# wip: data_addtolist\n';
    };

    Blockly.Ruby.data_deleteoflist = function (block) {
        return '# wip: data_deleteoflist\n';
    };

    Blockly.Ruby.data_deletealloflist = function (block) {
        return '# wip: data_deletealloflist\n';
    };

    Blockly.Ruby.data_insertatlist = function (block) {
        return '# wip: data_insertatlist\n';
    };

    Blockly.Ruby.data_replaceitemoflist = function (block) {
        return '# wip: data_replaceitemoflist\n';
    };

    Blockly.Ruby.data_itemoflist = function (block) {
        return '# wip: data_itemoflist\n';
    };

    Blockly.Ruby.data_itemnumoflist = function (block) {
        return '# wip: data_itemnumoflist\n';
    };

    Blockly.Ruby.data_lengthoflist = function (block) {
        return ['"wip: data_lengthoflist"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.data_listcontainsitem = function (block) {
        return ['"wip: data_listcontainsitem"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.data_showlist = function (block) {
        return '# wip: data_showlist\n';
    };

    Blockly.Ruby.data_hidelist = function (block) {
        return '# wip: data_hidelist\n';
    };

    Blockly.Ruby.motion_movesteps = function (block) {
        return '# wip: motion_movesteps\n';
    };

    Blockly.Ruby.motion_turnright = function (block) {
        return '# wip: motion_turnright\n';
    };

    Blockly.Ruby.motion_turnleft = function (block) {
        return '# wip: motion_turnleft\n';
    };

    Blockly.Ruby.motion_pointindirection = function (block) {
        return '# wip: motion_pointindirection\n';
    };

    Blockly.Ruby.motion_pointtowards_menu = function (block) {
        return '# wip: motion_pointtowards_menu\n';
    };

    Blockly.Ruby.motion_pointtowards = function (block) {
        return '# wip: motion_pointtowards\n';
    };

    Blockly.Ruby.motion_goto_menu = function (block) {
        return '# wip: motion_goto_menu\n';
    };

    Blockly.Ruby.motion_gotoxy = function (block) {
        return '# wip: motion_gotoxy\n';
    };

    Blockly.Ruby.motion_goto = function (block) {
        return '# wip: motion_goto\n';
    };

    Blockly.Ruby.motion_glidesecstoxy = function (block) {
        return '# wip: motion_glidesecstoxy\n';
    };

    Blockly.Ruby.motion_glideto_menu = function (block) {
        return '# wip: motion_glideto_menu\n';
    };

    Blockly.Ruby.motion_glideto = function (block) {
        return '# wip: motion_glideto\n';
    };

    Blockly.Ruby.motion_changexby = function (block) {
        return '# wip: motion_changexby\n';
    };

    Blockly.Ruby.motion_setx = function (block) {
        return '# wip: motion_setx\n';
    };

    Blockly.Ruby.motion_changeyby = function (block) {
        return '# wip: motion_changeyby\n';
    };

    Blockly.Ruby.motion_sety = function (block) {
        return '# wip: motion_sety\n';
    };

    Blockly.Ruby.motion_ifonedgebounce = function (block) {
        return '# wip: motion_ifonedgebounce\n';
    };

    Blockly.Ruby.motion_setrotationstyle = function (block) {
        return '# wip: motion_setrotationstyle\n';
    };

    Blockly.Ruby.motion_xposition = function (block) {
        return ['"wip: motion_xposition"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.motion_yposition = function (block) {
        return ['"wip: motion_yposition"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.motion_direction = function (block) {
        return ['"wip: motion_direction"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.motion_scroll_right = function (block) {
        return '# wip: motion_scroll_right\n';
    };

    Blockly.Ruby.motion_scroll_up = function (block) {
        return '# wip: motion_scroll_up\n';
    };

    Blockly.Ruby.motion_align_scene = function (block) {
        return '# wip: motion_align_scene\n';
    };

    Blockly.Ruby.motion_xscroll = function (block) {
        return ['"wip: motion_xscroll"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.motion_yscroll = function (block) {
        return ['"wip: motion_yscroll"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.looks_sayforsecs = function (block) {
        return '# wip: looks_sayforsecs\n';
    };

    Blockly.Ruby.looks_say = function (block) {
        return '# wip: looks_say\n';
    };

    Blockly.Ruby.looks_thinkforsecs = function (block) {
        return '# wip: looks_thinkforsecs\n';
    };

    Blockly.Ruby.looks_think = function (block) {
        return '# wip: looks_think\n';
    };

    Blockly.Ruby.looks_show = function (block) {
        return '# wip: looks_show\n';
    };

    Blockly.Ruby.looks_hide = function (block) {
        return '# wip: looks_hide\n';
    };

    Blockly.Ruby.looks_hideallsprites = function (block) {
        return '# wip: looks_hideallsprites\n';
    };

    Blockly.Ruby.looks_changeeffectby = function (block) {
        return '# wip: looks_changeeffectby\n';
    };

    Blockly.Ruby.looks_seteffectto = function (block) {
        return '# wip: looks_seteffectto\n';
    };

    Blockly.Ruby.looks_cleargraphiceffects = function (block) {
        return '# wip: looks_cleargraphiceffects\n';
    };

    Blockly.Ruby.looks_changesizeby = function (block) {
        return '# wip: looks_changesizeby\n';
    };

    Blockly.Ruby.looks_setsizeto = function (block) {
        return '# wip: looks_setsizeto\n';
    };

    Blockly.Ruby.looks_size = function (block) {
        return ['"wip: looks_size"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.looks_changestretchby = function (block) {
        return '# wip: looks_changestretchby\n';
    };

    Blockly.Ruby.looks_setstretchto = function (block) {
        return '# wip: looks_setstretchto\n';
    };

    Blockly.Ruby.looks_costume = function (block) {
        return '# wip: looks_costume\n';
    };

    Blockly.Ruby.looks_switchcostumeto = function (block) {
        return '# wip: looks_switchcostumeto\n';
    };

    Blockly.Ruby.looks_nextcostume = function (block) {
        return '# wip: looks_nextcostume\n';
    };

    Blockly.Ruby.looks_switchbackdropto = function (block) {
        return '# wip: looks_switchbackdropto\n';
    };

    Blockly.Ruby.looks_backdrops = function (block) {
        return '# wip: looks_backdrops\n';
    };

    Blockly.Ruby.looks_gotofrontback = function (block) {
        return '# wip: looks_gotofrontback\n';
    };

    Blockly.Ruby.looks_goforwardbackwardlayers = function (block) {
        return '# wip: looks_goforwardbackwardlayers\n';
    };

    Blockly.Ruby.looks_backdropnumbername = function (block) {
        return ['"wip: looks_backdropnumbername"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.looks_costumenumbername = function (block) {
        return ['"wip: looks_costumenumbername"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.looks_switchbackdroptoandwait = function (block) {
        return '# wip: looks_switchbackdroptoandwait\n';
    };

    Blockly.Ruby.looks_nextbackdrop = function (block) {
        return '# wip: looks_nextbackdrop\n';
    };

    Blockly.Ruby.sound_sounds_menu = function (block) {
        return '# wip: sound_sounds_menu\n';
    };

    Blockly.Ruby.sound_play = function (block) {
        return '# wip: sound_play\n';
    };

    Blockly.Ruby.sound_playuntildone = function (block) {
        return '# wip: sound_playuntildone\n';
    };

    Blockly.Ruby.sound_stopallsounds = function (block) {
        return '# wip: sound_stopallsounds\n';
    };

    Blockly.Ruby.sound_seteffectto = function (block) {
        return '# wip: sound_seteffectto\n';
    };

    Blockly.Ruby.sound_changeeffectby = function (block) {
        return '# wip: sound_changeeffectby\n';
    };

    Blockly.Ruby.sound_cleareffects = function (block) {
        return '# wip: sound_cleareffects\n';
    };

    Blockly.Ruby.sound_changevolumeby = function (block) {
        return '# wip: sound_changevolumeby\n';
    };

    Blockly.Ruby.sound_setvolumeto = function (block) {
        return '# wip: sound_setvolumeto\n';
    };

    Blockly.Ruby.sound_volume = function (block) {
        return ['"wip: sound_volume"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.event_whentouchingobject = function (block) {
        return '# wip: event_whentouchingobject\n';
    };

    Blockly.Ruby.event_touchingobjectmenu = function (block) {
        return ['"wip: event_touchingobjectmenu"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.event_whenflagclicked = function (block) {
        return '# wip: event_whenflagclicked\n';
    };

    Blockly.Ruby.event_whenthisspriteclicked = function (block) {
        return '# wip: event_whenthisspriteclicked\n';
    };

    Blockly.Ruby.event_whenstageclicked = function (block) {
        return '# wip: event_whenstageclicked\n';
    };

    Blockly.Ruby.event_whenbroadcastreceived = function (block) {
        return '# wip: event_whenbroadcastreceived\n';
    };

    Blockly.Ruby.event_whenbackdropswitchesto = function (block) {
        return '# wip: event_whenbackdropswitchesto\n';
    };

    Blockly.Ruby.event_whengreaterthan = function (block) {
        return '# wip: event_whengreaterthan\n';
    };

    Blockly.Ruby.event_broadcast_menu = function (block) {
        return ['"wip: event_broadcast_menu"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.event_broadcast = function (block) {
        return '# wip: event_broadcast\n';
    };

    Blockly.Ruby.event_broadcastandwait = function (block) {
        return '# wip: event_broadcastandwait\n';
    };

    Blockly.Ruby.event_whenkeypressed = function (block) {
        return '# wip: event_whenkeypressed\n';
    };

    Blockly.Ruby.extension_pen_down = function (block) {
        return '# wip: extension_pen_down\n';
    };

    Blockly.Ruby.extension_music_drum = function (block) {
        return '# wip: extension_music_drum\n';
    };

    Blockly.Ruby.extension_wedo_motor = function (block) {
        return '# wip: extension_wedo_motor\n';
    };

    Blockly.Ruby.extension_wedo_hat = function (block) {
        return '# wip: extension_wedo_hat\n';
    };

    Blockly.Ruby.extension_wedo_boolean = function (block) {
        return ['"wip: extension_wedo_boolean"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.extension_wedo_tilt_reporter = function (block) {
        return ['"wip: extension_wedo_tilt_reporter"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.extension_wedo_tilt_menu = function (block) {
        return ['"wip: extension_wedo_tilt_menu"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.extension_music_reporter = function (block) {
        return ['"wip: extension_music_reporter"', Blockly.Ruby.ORDER_ATOMIC];
    };

    Blockly.Ruby.extension_microbit_display = function (block) {
        return '# wip: extension_microbit_display\n';
    };

    return Blockly;
}
